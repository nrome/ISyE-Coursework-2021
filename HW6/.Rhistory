D = matrix(c(2, 9, 3, 5, 7, 4, 5, 7, 7, 5, 5, 5, 1, 2, 4, 8))
D
D = matrix(c(2, 9, 3, 5, 7, 4, 5, 7, 7, 5, 5, 5, 1, 2, 4, 8), ncol = 2, byrow = TRUE)
D
rownames(D) = c('A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2')
colname(D)  = c('x', 'y')
colnames(D)  = c('x', 'y')
D
#   Three Clusters A1, B1, C1 centers
center = D[c('A1', 'B1', 'C1')]
center
#   Three Clusters A1, B1, C1 centers
center = D[c('A1', 'B1', 'C1'),]
center
plot(D)
points(center, col = 'red', pch = 13)
#   Distance function is Euclidean distance
dissim = dist(rbind(D, center), method = 'euclidean')
dissim
npoint = nrow(D)
dissim = dissim[1:npoint, -(1:npoint)]
#   Convert to conventional matrix
dissim = as.matrix(dissim)
npoint = nrow(D)
dissim = dissim[1:npoint, -(1:npoint)]
dissim
dissim
#   group by min value
group = apply(dissim, MARGIN = 1, FUN = which.min)
#   group by min value
group = apply(dissim, MARGIN = 1, FUN = which.min)
group
kmeans.group = function(D, center) {
+ npoint = nrow(D)
+ dissim = dist(rbind(D, center), method = 'euclidean')
+ dissim = as.matrix(dissim)
+ dissim = dissim[1:npoint, -(1:npoint)]
+ group = apply(dissim, MARGIN = 1, FUN = which.min)
+ return(grouping)
}
kmeans.group(D, center)
+ }
+ }
kmeans.group = function(D, center) {
+ npoint = nrow(D)
+ dissim = dist(rbind(D, center), method = 'euclidean')
+ dissim = as.matrix(dissim)
+ dissim = dissim[1:npoint, -(1:npoint)]
+ group = apply(dissim, MARGIN = 1, FUN = which.min)
+ return(group)
}
kmeans.group(D, center)
group
kmeans.group = function(D, center) {
+ npoint = nrow(D)
+ dissim = dist(rbind(D, center), method = 'euclidean')
+ dissim = as.matrix(dissim)
+ dissim = dissim[1:npoint, -(1:npoint)]
+ group = apply(dissim, MARGIN = 1, FUN = which.min)
+ return(group)
}
kmeans.group(D, center)
group
plot(D, col = group)
kmeans.group = function(D, center){}
+
#   Clean environment
rm(list = ls())
#   Uninstall packages
p_unload(all)
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
#   Load packages with pacman
pacman::p_load(pacman)
D = matrix(c(2, 9, 3, 5, 7, 4, 5, 7, 7, 5, 5, 5, 1, 2, 4, 8), ncol = 2, byrow = TRUE)
#   Represent eight datasets
rownames(D) = c('A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2')
#   Denote x and y coordinates
colnames(D)  = c('x', 'y')
#   Three Clusters A1, B1, C1 centers
center = D[c('A1', 'B1', 'C1'),]
center
#   Distance function is Euclidean distance
dissim = dist(rbind(D, center), method = 'euclidean')
#   Convert to conventional matrix
dissim = as.matrix(dissim)
dissim
#   8 points
npoint = nrow(D)
#   first eight rows and all columns except first eight columns
dissim = dissim[1:npoint, -(1:npoint)]
dissim
#   group by min value - returns columns w/ smallest val w/in each row
group = apply(dissim, MARGIN = 1, FUN = which.min)
group
plot(D, col = group)
kmeans.group = function(D, center) {
+ npoint = nrow(D)
+ dissim = dist(rbind(D, center), method = 'euclidean')
+ dissim = as.matrix(dissim)
+ dissim = dissim[1:npoint, -(1:npoint)]
+ group = apply(dissim, MARGIN = 1, FUN = which.min)
+ return(group)
}
kmeans.group(D, center)
kmeans.group = function(D, center) {
npoint = nrow(D)
+ dissim = dist(rbind(D, center), method = 'euclidean')
+ dissim = as.matrix(dissim)
+ dissim = dissim[1:npoint, -(1:npoint)]
+ group = apply(dissim, MARGIN = 1, FUN = which.min)
+ return(group)
}
kmeans.group(D, center)
kmeans.group = function(D, center) {
npoint = nrow(D)
dissim = dist(rbind(D, center), method = 'euclidean')
dissim = as.matrix(dissim)
dissim = dissim[1:npoint, -(1:npoint)]
group = apply(dissim, MARGIN = 1, FUN = which.min)
return(group)
}
kmeans.group(D, center)
kmeans.group(D, center) == group
center.x = aggregate(D[,1], by = list(group), FUN = mean)
center.x
center.y = aggregate(D[,2], by = list(group), FUN = mean)
center.y
center = cbind(center.x$x, center.y$x)
center
points(center, col = 1:3, pch = 8)
#   test center
kmeans.newcenter(D, group) == center
kmeans.newcenter = function(D, group){
center.x = aggregate(D[,1], by = list(group), FUN = mean)
center.y = aggregate(D[,2], by = list(group), FUN = mean)
center = cbind(center.x$x, center.y$x)
return(center)
}
#   test center
kmeans.newcenter(D, group) == center
#   Calculate using center points
group = kmeans.group(D, center)
plot(D, col = group)
group
group
group
center = kmeans.newcenter(D, group)
points(center, col = 1:3, pch = 8)
group = kmeans.group(D, center)
plot(D, col = group)
group
plot(D, col = group)
kmeans.newcenter(D, group)
#   Clean environment
rm(list = ls())
#   Uninstall packages
p_unload(all)
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
D = matrix(c(2, 9, 3, 5, 7, 4, 5, 7, 7, 5, 5, 5, 1, 2, 4, 8), ncol = 2, byrow = TRUE)
#   Represent eight datasets
rownames(D) = c('A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2')
#   Denote x and y coordinates
colnames(D)  = c('x', 'y')
#   Three Clusters A1, B1, C1 centers
center = D[c('A1', 'B1', 'C1'),]
#   Use the k-means algorithm to show only
#   Assignment step:
kmeans.group = function(D, center) {
npoint = nrow(D)
dissim = dist(rbind(D, center), method = 'euclidean')
dissim = as.matrix(dissim)
dissim = dissim[1:npoint, -(1:npoint)]
group = apply(dissim, MARGIN = 1, FUN = which.min)
return(group)
}
#   test group
kmeans.group(D, center) == group
#   group by min value - returns columns w/ smallest val w/in each row
group = apply(dissim, MARGIN = 1, FUN = which.min)
#   Clean environment
rm(list = ls())
#   Uninstall packages
p_unload(all)
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
D = matrix(c(2, 9, 3, 5, 7, 4, 5, 7, 7, 5, 5, 5, 1, 2, 4, 8), ncol = 2, byrow = TRUE)
#   Represent eight datasets
rownames(D) = c('A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2')
#   Denote x and y coordinates
colnames(D)  = c('x', 'y')
#   Three Clusters A1, B1, C1 centers
center = D[c('A1', 'B1', 'C1'),]
#   Distance function is Euclidean distance
dissim = dist(rbind(D, center), method = 'euclidean')
#   Convert to conventional matrix
dissim = as.matrix(dissim)
#   8 points
npoint = nrow(D)
#   first eight rows and all columns except first eight columns
dissim = dissim[1:npoint, -(1:npoint)]
dissim
#   group by min value - returns columns w/ smallest val w/in each row
group = apply(dissim, MARGIN = 1, FUN = which.min)
#   Use the k-means algorithm to show only
#   Assignment step:
kmeans.group = function(D, center) {
npoint = nrow(D)
dissim = dist(rbind(D, center), method = 'euclidean')
dissim = as.matrix(dissim)
dissim = dissim[1:npoint, -(1:npoint)]
group = apply(dissim, MARGIN = 1, FUN = which.min)
return(group)
}
#   test group
kmeans.group(D, center) == group
#   Update step:
kmeans.newcenter = function(D, group){
center.x = aggregate(D[,1], by = list(group), FUN = mean)
center.y = aggregate(D[,2], by = list(group), FUN = mean)
center = cbind(center.x$x, center.y$x)
return(center)
}
#   test center
kmeans.newcenter(D, group) == center
#   Calculate using center points
group = kmeans.group(D, center)
#   group
plot(D, col = group)
group
center = kmeans.newcenter(D, group)
points(center, col = 1:3, pch = 8)
group = kmeans.group(D, center)
group
plot(D, col = group)
#   R built in kmeans lib
D
print(cl)
cl = kmeans(D, centers = D[c('A1', 'B1', 'C1'),], algorithm = "MacQueen")
print(cl)
plot(D, col = cl$cluster)
#   three resorting center points
points(cl$centers, col = 1:3, pch = 8)
#   Load packages with pacman
pacman::p_load(pacman, animation)
oopt = ani.options(interval = 2)
kmeans.ani(D, center = 3)
#   Load packages with pacman
pacman::p_load(pacman, animation, cluster)
sim = diag(0,5, nrow = 5)
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
dist = 1 - sim
dist
#   AGNES
agn = agnes(dist, method = "single")
plot(agn)
agn = agnes(sim, dist = F, method = "single")
agn = agnes(sim, diss = F, method = "single")
plot(agn)
#   Diana Algorithm
dv = diana(dist)
plot(dv)
#   Calculate using center points
#   first execution
group = kmeans.group(D, center)
plot(D, col = group)
#   Calculate new center points
#   final points where groups no longer change/converge
center = kmeans.newcenter(D, group)
points(center, col = 1:3, pch = 8)
group = kmeans.group(D, center)
plot(D, col = group)
points(center, col = 1:3, pch = 8)
points(center, col = 1:3, pch = 8)
group = kmeans.group(D, center)
plot(D, col = group)
cl = kmeans(D, centers = D[c('A1', 'B1', 'C1'),], algorithm = "MacQueen")
print(cl)
kmeans.group(D, center)
group
center
#   Distance function is Euclidean distance
dissim = dist(rbind(D, center), method = 'euclidean')
dissim
#   Convert to conventional matrix
dissim = as.matrix(dissim)
dissim
#   group by min value - returns columns w/ smallest val w/in each row
group = apply(dissim, MARGIN = 1, FUN = which.min)
group
group = kmeans.group(D, center)
group = kmeans.group(D, center)
group
sim = diag(0,5, nrow = 5)
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
sim[upper.tri(sim)] = c(1.0,0.1,0.41,0.64,0.55,0.47,0.44,0.35,0.98,0.85,0.76)
sim[upper.tri(sim)] = c(1.0,0.41,0.64,0.55,0.47,0.44,0.35,0.98,0.85,0.76)
sim = sim + t(sim)
sim
sim[upper.tri(sim)] = c(0.1,0.41,0.64,0.55,0.47,0.44,0.35,0.98,0.85,0.76)
sim = sim + t(sim)
sim
dist = 1 - sim
dist
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
#   Clean environment
rm(list = ls())
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
sim = diag(0,5, nrow = 5)
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
#   Single Link
agn = agnes(sim, diss = F, method = "single")
plot(agn)
#   Complete Link
agn = agnes(sim, diss = F, method = "complete")
plot(agn)
#   Complete Link
agn = agnes(sim, diss = F, method = "complete")
plot(agn)
sim = sim + t(sim)
sim
#   Clean environment
rm(list = ls())
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
sim = diag(1,5, nrow = 5)
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
#   Clean environment
rm(list = ls())
#   Remove plots
dev.off()  # do only if a plot exists
#   Clear the console
cat("\014")   # command shortcut ctrl+L
sim = diag(.5,5, nrow = 5)
sim[upper.tri(sim)] = c(0.1, 0.41, 0.64, 0.55, 0.47, 0.44, 0.35, 0.98, 0.85, 0.76)
sim = sim + t(sim)
sim
#   Single Link
agn = agnes(sim, diss = F, method = "single")
plot(agn)
plot(agn)
plot(agn)
plot(dv)
#   Complete Link
agn = agnes(sim, diss = F, method = "complete")
plot(agn)
#   Load packages with pacman
pacman::p_load(pacman, animation, cluster)
dataset = c(8, 10, 24, 28, 30, 40, 46)
i  = c(8, 10, 24, 28)
ii = c(30, 40, 46)
dataset = c(8, 10, 24, 28, 30, 40, 46)
#   { 16, 42 }
i  = c(8, 10, 24, 28)
#   { 10, 40 }
ii = c(30, 40, 46)
#   Single Link / AGNES
agn = agnes(dataset, method = "single")
plot(agn)
rm(list = ls())
#   Single Link / AGNES
agn = agnes(i, method = "single")
#   { 16, 42 }
cl.1  = c(8, 10, 24, 28)
#   { 10, 40 }
cl.2  = c(30, 40, 46)
#   Single Link / AGNES
agn = agnes(cl.1, method = "single")
plot(agn)
plot(agn)
plot(agn)
#   Single Link / AGNES
agn = agnes(cl.2, method = "single")
plot(agn)
#   Uninstall packages
p_unload(all)
dataset = c(8, 10, 24, 28, 30, 40, 46)
#   Three Clusters A1, B1, C1 centers
ds.center = D[c('16', '42'),]
ds.center
#   Three Clusters A1, B1, C1 centers
ds.center = dataset[c('16', '42'),]
dataset = matrix(c(8, 10, 24, 28, 30, 40, 46), ncol = 2, byrow = TRUE)
#   Denote x and y coordinates
colnames(dataset)  = c('x', 'y')
#   Three Clusters A1, B1, C1 centers
ds.center = dataset[c('16', '42'),]
#   Represent eight datasets
rownames(dataset) = c('cl1', 'cl2')
dataset = matrix(c(8, 10, 24, 28, 30, 40, 46), ncol = 2, byrow = TRUE)
#   { 16, 42 }
cl.1  = c(8, 10, 24, 28)
#   { 10, 40 }
cl.2  = c(30, 40, 46)
#   Represent eight datasets
rownames(dataset) = c('cl1', 'cl2')
#   Load packages with pacman
pacman::p_load(pacman, animation, cluster)
#   Process until results converge
oopt = ani.options(interval = 2)
kmeans.ani(dataset, center = 3)
#   Process until results converge
oopt = ani.options(interval = 2)
kmeans.ani(dataset, center = 2)
